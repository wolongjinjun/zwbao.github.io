# 磁盘及文件系统管理

## 硬盘物理结构及相关概念

1. 硬盘内部视角实物图

[![wKiom1ZRq1yQx4mfAACdd-lVZ9o949.jpg](http://s1.51cto.com/wyfs02/M02/76/5F/wKiom1ZRq1yQx4mfAACdd-lVZ9o949.jpg)](http://s1.51cto.com/wyfs02/M02/76/5F/wKiom1ZRq1yQx4mfAACdd-lVZ9o949.jpg)

[![wKiom1ZSeS3zD9uYAABnE-xRe5s135.jpg](http://s1.51cto.com/wyfs02/M01/76/63/wKiom1ZSeS3zD9uYAABnE-xRe5s135.jpg)](http://s1.51cto.com/wyfs02/M01/76/63/wKiom1ZSeS3zD9uYAABnE-xRe5s135.jpg)

2. 硬盘内部视角逻辑图

[![wKiom1ZRrv6R7MVDAADb_shIiTU236.png](http://s3.51cto.com/wyfs02/M00/76/60/wKiom1ZRrv6R7MVDAADb_shIiTU236.png)](http://s3.51cto.com/wyfs02/M00/76/60/wKiom1ZRrv6R7MVDAADb_shIiTU236.png)

3. 扇区、磁道、柱面图

[![wKioL1ZRr5jBRRhoAAAy_xkJaBs736.jpg](http://s2.51cto.com/wyfs02/M00/76/5F/wKioL1ZRr5jBRRhoAAAy_xkJaBs736.jpg)](http://s2.51cto.com/wyfs02/M00/76/5F/wKioL1ZRr5jBRRhoAAAy_xkJaBs736.jpg)  [![wKioL1ZRsxHz6Q6mAAD8gz1PyVE618.gif](http://s1.51cto.com/wyfs02/M00/76/5F/wKioL1ZRsxHz6Q6mAAD8gz1PyVE618.gif)](http://s1.51cto.com/wyfs02/M00/76/5F/wKioL1ZRsxHz6Q6mAAD8gz1PyVE618.gif)

-  磁头(head)数：每个盘片一般有上下两面，分别对应1个磁头，共2个磁头,实现数据的存取
-  磁道(track)：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道，从外边缘的0开始编号，根据磁化方向来存数数据0和1
-  柱面(cylinder)：不同盘片的相同编号的磁道构成的圆柱面就被称之为柱面，磁盘的柱面数与一个盘面上的磁道数是相等的
-  扇区(sector)：每个磁道都别切分成很多扇形区域，每个磁道的扇区数量相同，每个扇区大小为512字节
-  平均寻道时间：它是了解硬盘性能至关重要的参数之一。它是指硬盘在接收到系统指令后，磁头从开始移动到数据所在的磁道所花费时间的平均值，它在一定程度上体现了硬盘读取数据的能力，是影响硬盘内部数据传输率的重要参数，单位为毫秒（ms）。外面柱面速度比内部的快（角速度一样，在同样时间划过的距离更长，读写速率高），所以将一些频繁访问的内容放在靠近外部的柱面，比如C盘。

硬盘的容量=柱面数×磁头数×扇区数×512（字节数）

## 硬盘逻辑结构及相关概念

### MBR（Master Boot Record / Main Boot Record）：

主引导记录 (512byte)是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。
由三个部分组成(共占用512个字节)：

- 446bytes: BootLoader, 引导程序
- 64bytes:
  - 每16bytes标识一个分区，所以最多只有四个主分区，为了使用更多分区，可以将一个分区设置为扩展分区，相当于一个指针，指向硬盘上更大的空间，以存放额外的分区信息。（主+扩展 <= 4）磁盘分区是按照柱面进行的
  - 2bytes: Magic Number，标记MBR是否有效


**操作系统的启动**：BIOS自检完成后，根据BIOS中设定的启动次序，依次查找启动设备的MBR，没有MBR则下一个，有MBR但坏了则系统报错，无法启动；先将BootLoader加载到内存中，BIOS退出，BootLoader程序首先读取分区表，根据配置，加载对应分区上操作系统的内核，如果没有分区表则无法找到操作系统；BootLoader会将内核读进内存，内存读入并解压缩后BootLoader将控制权交给内核，内核开始启动自身，根据文件配置找到文件系统在什么地方，找到所需要运行的程序的位置，最终完成启动操作系统。

### 主分区、扩展分区、逻辑分区

[![wKioL1ZRwlPBVaDfAADMWZrpCNI498.jpg](http://s4.51cto.com/wyfs02/M01/76/5F/wKioL1ZRwlPBVaDfAADMWZrpCNI498.jpg)](http://s4.51cto.com/wyfs02/M01/76/5F/wKioL1ZRwlPBVaDfAADMWZrpCNI498.jpg)

- 主分区+扩展分区<=4
- 扩展分区最多只有一个
- 要么是三主一扩展，要么是四个主分区，那么剩余未分区的空间将无法使用

### 目录文件

[![wKioL1ZR5JPhFXJlAABJ5Uca7fQ102.jpg](http://s5.51cto.com/wyfs02/M02/76/60/wKioL1ZR5JPhFXJlAABJ5Uca7fQ102.jpg)](http://s5.51cto.com/wyfs02/M02/76/60/wKioL1ZR5JPhFXJlAABJ5Uca7fQ102.jpg)

1. 文件名和文件类型都是在目录中存放，而文件的其他元数据信息则是在Inode中存放
2. 文件系统各分区之间物理视角上是并行的，逻辑视角上必须得有上下级关系，所有的文件都必须直接或间接从根开始
### swap分区：
Swap分区在系统的物理内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。

### 页框（page frame）：
内存管理的概念，CPU中添加了能自动把虚拟内存（即逻辑地址）地址转化为物理内存地址的电路，为了简化这种电路，就把RAM划分为长度为4KB或8KB的块，这种块就叫页框。

### 超级块（Super Block）

描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等，超级块在每个块组的开头都有一份拷贝。

### 块组描述符表（GDT，Group Descriptor Table）

由很多块组描述符组成，整个分区分成多少个块组就对应有多少个块组描述符；每个块组描述符（Group Descriptor）存储一个块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等；和超级块类似，块组描述符表在每个块组的开头也都有一份拷贝，这些信息是非常重要的，一旦超级块意外损坏就会丢失整个分区的数据，一旦块组描述符意外损坏就会丢失整个块组的数据，因此它们都有多份拷贝。

### 块位图（BlockBitmap）

块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块，其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用；与此相联系的另一个问题是：在格式化一个分区时究竟会划出多少个块组呢？主要的限制在于块位图本身必须只占一个块。

### inode位图（inodeBitmap）

和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。

### inode表（inodeTable）

一个文件除了数据需要存储之外，一些描述信息也需要存储，例如文件类型（常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间等，也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中每个文件都有一个inode，一个块组中的所有inode组成了inode表；inode表占多少个块在格式化时就要决定并写入块组描述符中；mke2fs格式化工具的默认策略是一个块组有多少个8KB就分配多少个inode。

### 数据块（DataBlock）

- 对于常规文件，文件的数据存储在数据块中
- 对于目录，该目录下的所有文件名和目录名存储在数据块中，文件名保存在它所在目录的数据块中
  - 除文件名之外，ls-l命令看到的其它信息都保存在该文件的inode中
  - 目录也是一种文件，是一种特殊类型的文件
- 对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存
- 设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中
## 读取、创建、删除、复制、剪切过程

### 读取文件

首先根是自引用的，也就是根的Inode号是已知的，再根据Inode Table可以知道根的Inode号对应的Block号，然后找到对应的block，block里面有个目录项，也即Dentry，每个目录项记录了根下所有直接子目录的Inode与文件名的对应关系(也包括文件类型等)，例如var对应的Inode号为2883585，etc对应的Inode号为1507329等等，此时找到etc文件对应的Inode号，再通过查找Inode Table可以得知etc文件对应的Block，再通过读取Block里面的Dentry可以得知httpd文件对应的Inode，再查找Inode Table可以查到httpd文件对应的Block，再在对应的Block里面查询Dentry可以得知httpd.conf文件对应的Inode号，再次查询Inode Table可以找到对应的Block，于是数据就可以读取了。

### 创建文件

想要创建一个文件，首先得先给这个文件分配Inode和Block。首先扫描Inode Bitmap查找空闲Inode，再去Inode Table中写入想要创建文件的元数据，例如权限、属主属组、大小、时间戳、以及这个Inode对应所占据的Block。然后再找到根的Inode，找到根对应的Block，里面Dentry记录了etc及其对应的Inode，再通过Inode Table找到etc文件对应的Block，于是在Dentry里面添加一条记录，testfile.txt与其对应的Inode号，文件类型等信息。到此一个文件便创建了。

### 删除文件

删除文件直接上级目录(etc)里面的那条Dentry记录，Inode Bitmap里面把文件(fstab)原先对应的Inode号标记为未使用，Block Bitmap中把文件(fstab)原先对应的Block标记为未使用。删除文件本身并没有删除文件所对应的Block和Inode，也就是说Block上的数据并没有被抹除，除非后面向其Block中覆盖数据。

### 复制文件

复制文件本质就是新建一个文件，并填充源文件数据的过程，详细可参考上面的创建和读取文件过程。

### 剪切文件

在同一个分区下，剪切速度非常快，这是因为其本质也只是将Dentry记录换一个目录而已，所以根本就不涉及什么耗时的操作。而跨分区剪切文件的过程其实就是在另外一个分区上创建一个新文件，并复制，复制完成之后再删除原先分区上数据的一个过程。

## 软连接与硬链接

- 硬链接：两个路径指向同一个inode，对于硬链接，硬链接的次数大于2时，删除该文件时不会被真正删除，只有小于等于1是再删除是彻底删除
- 软链接：一个路径指向的inode，存储的是另一个路径（文件大小是字符个数）

```shell
-s或——symbolic：对源文件建立符号连接，而非硬连接；
-v或——verbose：显示指令执行过程；
```

### 创建链接：

**ln命令**用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用"-s"选项。

注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。

- 源文件：指定连接的源文件。如果使用`-s`选项创建符号连接，则“源文件”可以是文件或者目录。创建硬连接时，则“源文件”参数只能是文件；
- 目标文件：指定源文件的目标连接文件。

例：将目录`/usr/mengqc/mub1`下的文件m2.c链接到目录`/usr/liu`下的文件a2.c 

```shell
cd /usr/mengqc
ln /mub1/m2.c /usr/liu/a2.c
```

### 【总结】：

- 硬链接：

1. 只能对文件创建，不能应用于目录；
2. 不能跨文件系统；
3. 创建硬链接会增加文件被链接的次数；

- 符号链接：

1. 可应用于目录；
2. 可以跨文件系统；
3. 不会增加被链接文件的链接次数；
4. 其大小为指定的路径所包含的字符个数；

## 文件系统管理相关命令

### du：

**du命令**也是查看使用空间的，但是与[df](http://man.linuxde.net/df)命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。

```shell
-s或--summarize 仅显示总计，只列出最后加总的值；
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
```

### df：

**df命令**用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

```shell
-i或--inodes：显示inode的信息；
-P或--portability：使用POSIX的输出格式，即一行的内容放在同一行显示，不换行；
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
```

### mknod：

**mknod命令**用于创建Linux中的字符设备文件和块设备文件。

回顾：

```
设备文件：

b: 按块为单位，随机访问的设备；硬盘
c：按字符为单位，线性设备，有先后次序；键盘

没有大小

主设备号 （major number）：标识设备类型
次设备号 （minor number）：标识同一种类型中不同设备
```

mknod [OPTION]... NAME TYPE [MAJOR MINOR]

```shell
-m MODE
```
### 硬盘设备的设备文件名：

IDE, ATA：以hd开头
SATA：以sd开头
SCSI：以sd开头
USB：以sd开头
​	a,b,c,...来区别同一种类型下的不同设备
IDE：一般有两个IDE口，每个IDE可以接两块盘
​	第一个IDE口：主、从
​	/dev/hda, /dev/hdb
​	第二个IDE口：主、从
​	/dev/hdc, /dev/hdd

以hda例：

hda1：第一个主分区
hda2：第二个主分区
hda3：第三个主分区
hda4：第四个主分区
hda5：第一个逻辑分区

逻辑分区可以有多个，扩展分区只能有一个，主分区最多有四个。

### 查看当前系统识别了几块硬盘：

fdisk -l [/dev/to/some_device_file]

### 管理磁盘分区：

```shell
fdisk /dev/sda
# 按住Ctrl和删除键可删除命令
p：显示当前硬件的分区，包括没保存的改动
n：创建新分区
	e: 扩展分区
	p: 主分区
d：删除一个分区
w：保存退出
q：不保存退出
t：修改分区类型 # 如改为swap需要，L命令，输入Linux swap / Solaris 的编码（82）
	L: 跟在t后使用，显示所支持的所有类型
l：不跟在t后使用，显示所支持的所有类型
```

但此时内核仍未识别，需要重读硬盘分区表，用`partprobe /dev/sda`命令；之后才能进行格式化。

低级格式化：厂商已经完成。

高级格式化：创建文件系统。

## 虚拟文件系统

虚拟文件系统又称虚拟文件系统转换（Virual Filesystem Switch ，简称VFS）。说它虚拟，是因为它所有的数据结构都是在运行以后才建立，并在卸载时删除，而在磁盘上并没有存储这些数据结构，显然如果只有VFS，系统是无法工作的，因为它的这些数据结构不能凭空而来，只有与实际的文件系统，如Ext2、Minix、MSDOS、VFAT等相结合，才能开始工作，所以VFS并不是一个真正的文件系统。与VFS相对，我们称Ext2、Minix、MSDOS等为具体文件系统。

VFS与内核其它子系统之间关系：

[![wKiom1ZT86LSHtcSAABXzDmkEcM146.gif](http://s4.51cto.com/wyfs02/M01/76/74/wKiom1ZT86LSHtcSAABXzDmkEcM146.gif)](http://s4.51cto.com/wyfs02/M01/76/74/wKiom1ZT86LSHtcSAABXzDmkEcM146.gif)

VFS提供一个统一的接口（实际上就是file_operatoin数据结构），一个具体文件系统要想被Linux支持，就必须按照这个接口编写自己的操作函数，而将自己的细节对内核其它子系统隐藏起来。因而，对内核其它子系统以及运行在操作系统之上的用户程序而言，所有的文件系统都是一样的。实际上，要支持一个新的文件系统，主要任务就是编写这些接口函数。

概括说来，VFS主要有以下几个作用：

1. 对具体文件系统的数据结构进行抽象，以一种统一的数据结构进行管理。
2. 接受用户层的系统调用 ，例如write、open、stat、link等等。
3. 支持多种具体文件系统之间相互访问。
4. 接受内核其他子系统的操作请求，特别是内存管理子系统。



## 文件系统管理：

重新创建文件系统会损坏原有文件，所以不要对已有数据的分区创建文件系统

### mkfs：make file system

```shell
-t FSTYPE
mkfs -t ext2 = mkfs.ext2
类似Windows上的快速格式化
```

`cat /proc/filesystem` 查看当前内核所支持的文件系统类型

###  mke2fs 专门挂载ext系列文件：

```shell
-j：创建ext3类型文件系统；
-b BLOCK_SIZE：指定块大小，默认为4096，可用取值为1024、2048或4096； # 经常存储小文件适合用小的，大文件用大的
-L LABEL：指定分区卷标，有了卷标，下次重新开机多个挂载的硬件设备次序不会乱，且可用卷标来引用该分区；
-m <数字>：指定预留给超级用户的预留百分比，默认为5%；
-i <数字>：指定为多少个字节预留一个inode，默认为8192，这里给出的数值应该为块大小的2^n倍；
-N：指定inode个数；
-F：强制创建文件系统，默认情况下，该文件系统已经被挂载了就会不允许创建；
-E：用于指定额外的文件系统属性；
```

### blkid

在Linux下可以使用**blkid命令**对查询设备上所采用文件系统类型进行查询。blkid主要用来对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID等信息进行查询。

### e2label:查看或定义卷标

```shell
e2label 设备文件 卷标：设定卷标
```

### tune2fs：无损调整文件系统的相关属性

```shell
-j：不损害原有数据，将ext2改为ext3类型文件系统；# 块大小属性不能更改
-l：显示超级块中的信息；
-L LABEL：设定或修改卷标；
-m <数字>：调整预留给超级用户的预留百分比；
-r：指定预留块数；
-o：设定默认挂载选项；acl
-c <数字>：指定挂载次数达到n次后进行自检，0或-1表示关闭此功能；
-C <数字>：每挂载n天后进行自检，0或-1表示关闭此功能。
```

### dumpe2fs：显示文件属性信息

```shell
-h：只显示超级块信息
```

###fsck：检查并修复Linux文件系统

```shell
-t FSTYPE：指定文件系统类型
-a：自动修复
```

### e2fsck：专门检查并修复ext2、ext3文件系统

```shell
-f：强制检查
-p：自动修复
```

### 挂载：将新的文件系统关联至当前根文件系统

### 卸载：将某文件系统与当前根文件系统的关联关系予以移除

### mount：挂载

```shell
mount 设备 挂载点
	设备：
	设备文件：/dev/sda5
	卷标：LABEL=""
	UUID：UUID=""
挂载点：目录
	要求：
		1.此目录没有被其他进程使用；
		2.目录得事先存在；
		3.目录中的原有文件将会暂时隐藏；
```

mount：显示当前系统已经挂载的设备及挂载点
mount [options] [-o options] DEVICE MOUNT_POINT

```shell
-a：表示挂载/etc/fstab文件中定义的所有文件系统
-n：默认情况下，mount命令每挂载一个设备，都会把挂载的设备信息保存至/etc/mtab文件；使用—n选项意味着挂载设备时，不把信息写入此文件；
-t FSTYPE：指定正在挂载设备上的文件系统的类型；不使用此选项时，mount会调用blkid命令获取对应文件系统的类型；
-r：只读挂载，挂载光盘时常用此选项
-w：读写挂载

-o：指定额外的挂载选项，也即指定文件系统启用的属性；
	remount：重新挂载当前文件系统
	ro：挂载为只读
	rw：读写挂载
	
mount命令还可以挂载iso镜像；
mount DEVICE MOUNT_POINT
-o loop：挂载本地回环设备
```


​			
挂载完成后，要通过挂载点访问对应文件系统上的文件；

### umount：卸载某文件系统

```shell
umount 设备
umount 挂载点	

卸载注意事项：
	挂载的设备没有进程使用；
```

### free ：查看物理内存和交换空间使用情况，默认单位为字节。

```shell
-m：以M为单位显示
```
缓冲（buffers）：避免速度慢的设备在接受数据时收到冲击。通常储存元数据。

缓存（cached）：为了重复使用，将经常使用的文件存至缓存（速度更快）。通常缓存数据。

都是为了衔接两个速度不同的设备，加速操作系统性能。

fdisk命令中，调整分区类型为82；

### 创建交换分区文件系统：

注意别忘了用`fdisk` 调整分区类型为 82，即 Linux swap / Solaris 的编码

```shell
mkswap /dev/sda8 
-L LABEL
```
启用交换分区：

```shell
swapon /dev/sda8
swapon -a：启用所有定义在/etc/fstab文件中的交换设备
```
关闭交换分区：

```shell
swapoff /dev/sda8
```

实在没空间可以使用了，还可以创建本地回环设备：

回环设备：使用软件来模拟实现硬件

### dd命令：

```shell
if=数据来源
of=数据存储目标
bs=1 一次复制多少字节 # bs=1M
count=2 一共复制几次
seek=<数字>：创建数据文件时，跳过的空间大小；
```

备份MBR:

```shell
dd if=/dev/sda of=/mnt/usb/mbr.backup bs=512 count=1
# 恢复
dd if=/mnt/usb/mbr.backup of=/dev/sda bs=512 count=1
```

mount挂载的文件系统在系统重启后将消失

文件系统的配置文件`/etc/fstab`：OS在初始时，会自动挂载此文件中定义的每个文件系统，文件内容从左到右为：

|  要挂载的设备   |    挂载点    | 文件系统类型 |   挂载选项   | 转储频率<数字>(每多少天做一次完全备份，0表示不备份) | 文件系统检测次序(只有根可以为1，0表示不检查) |
| :-------: | :-------: | :----: | :------: | :--------------------------: | :----------------------: |
| /dev/sda5 | /mnt/test |  ext3  | defaults |              0               |            0             |

### fuser：验正进程正在使用的文件或套接字文件

```shell
-v：查看某文件上正在运行的进程
-k：
-m
fuser -km MOUNT_POINT：终止正在访问此挂载点的所有进程
```
